using UnityEngine;
using System.Collections;
using Vectrosity;

	//This was significantly modified on April 27 2015

public class JennyShoot : MonoBehaviour {
	/// <summary>
	/// This is to instantiate the photon.
	/// Will need:platformer controller.
	/// </summary>//

	public static JennyShoot jennyShoot;

	public bool canShoot;

	Transform shotDialCover;


	public Color Guncolour, PulseColour;

	float dopplerSoftening; //get this from physics constants like the speed of light
	public float initialPulseColour; //as a wavelength

	public bool mouseShoot = true;
	
	
	
	
	Transform jennyTransform;
	
	LorentzContractionForJenny lorentzContractionForJenny;
	PlatformerController platformerController;
	//	TimeDilationJenny timeDilationJenny;
	
	//	HSBColourScript hSBColourScript;
	//	HSBColor hsbColor;
	
	public GameObject horizontalPhotonPulse, horizontalPhotonPulseIR, horizontalPhotonPulseUV;
	GameObject photonPulseClone;
	MeshRenderer photonRenderer;
	Material photonCloneMaterial;
	
	
	PhotonPulseSphere photonPulseScript;

	float hueOfPulse;
	
	//PhysicsConstants physicsConstants; 
	//GameObject physConst;
	float SpeedOfLight;
	float SpeedOfLightY;
	float ScaleFactorOfLight; 
	
	
	
	
	public float speedOfPulse, angleOfShotScaled, angleOfShotInGame;
	
	
	public float blueShift;
	float blueshiftFunction, sonicDopplerShift;
	float vX, vXOverC, gammaX = 1f;
	float a, b, tempGammaX;
	Color pulseColor;
		
	
	
	Vector2 mouseCoord, gunCoord;
	bool gunPointLeft, gunPointRight;
	[Range(0f,Mathf.PI*0.5f)]
	public float angleBelowHorizontal=Mathf.PI/6f;//30 degrees in radians
	float angleOfGun, tempAngleGun;

	
	
	GameObject gun;

	public VectorLine gunLineVec;
	public Material gunLineMaterial;
	//LineRenderer gunLine;
	RaycastHit2D gunLineRaycastHit;// this will give the player a spot to aim at.
	//this is the backing to the dial
	public Transform pulseDialColour;
	Transform dopplerCircle, shotDialHolder;
	Material pulseDialMaterial;
	
	float timeOfShot, timeBetweenShots, ratioOfTimes, 
		  oneOverTimeBetweenShots;
	//float defaultPulseWidth, defaultPulseLength;

	Vector3 locationOfShot;


	public enum ShotState
	{
		canShoot,
		startHolding,
		turnOffShoot,
		cantShoot,
		turnOnShoot,
		holdingSomething
	};
	public ShotState shotState = ShotState.canShoot;



	//public Transform shotDial2;
	GameObject shotDial;
	TextMesh wavelengthLabelMesh;



	bool shotComplete;
	
	public Texture2D cursor;





	///When Jenny is carrying something she should not be able to shoot at least for now.
	/// instead she will point the gun at  the carried object
	public Transform heldObject;



	//this is a 470 element array generated by running GenerateTheColorArray in python on my laptop
	Color[] wav2Color = new Color[] {new Color(0.0078431372549f,0.0f,0.0235294117647f),new Color(0.0078431372549f,0.0f,0.0235294117647f),new Color(0.0078431372549f,0.0f,0.0274509803922f),new Color(0.0078431372549f,0.0f,0.0313725490196f),new Color(0.0117647058824f,0.0f,0.0352941176471f),new Color(0.0117647058824f,0.0f,0.0392156862745f),new Color(0.0117647058824f,0.0f,0.0470588235294f),new Color(0.0156862745098f,0.0f,0.0509803921569f),new Color(0.0156862745098f,0.0f,0.0549019607843f),new Color(0.0196078431373f,0.0f,0.0627450980392f),new Color(0.0196078431373f,0.0f,0.0666666666667f),new Color(0.0235294117647f,0.0f,0.0745098039216f),new Color(0.0235294117647f,0.0f,0.078431372549f),new Color(0.0274509803922f,0.0f,0.0862745098039f),new Color(0.0313725490196f,0.0f,0.0941176470588f),new Color(0.0352941176471f,0.0f,0.101960784314f),new Color(0.0392156862745f,0.0f,0.109803921569f),new Color(0.0470588235294f,0.0f,0.117647058824f),new Color(0.0509803921569f,0.0f,0.129411764706f),new Color(0.0549019607843f,0.0f,0.137254901961f),new Color(0.0627450980392f,0.0f,0.145098039216f),new Color(0.0666666666667f,0.0f,0.152941176471f),new Color(0.0705882352941f,0.0f,0.160784313725f),new Color(0.0745098039216f,0.0f,0.16862745098f),new Color(0.0823529411765f,0.0f,0.180392156863f),new Color(0.0901960784314f,0.0f,0.192156862745f),new Color(0.0941176470588f,0.0f,0.203921568627f),new Color(0.105882352941f,0.0f,0.219607843137f),new Color(0.113725490196f,0.0f,0.235294117647f),new Color(0.121568627451f,0.0f,0.250980392157f),new Color(0.133333333333f,0.0f,0.266666666667f),new Color(0.141176470588f,0.0f,0.282352941176f),new Color(0.149019607843f,0.0f,0.298039215686f),new Color(0.160784313725f,0.0f,0.317647058824f),new Color(0.172549019608f,0.0f,0.337254901961f),new Color(0.18431372549f,0.0f,0.356862745098f),new Color(0.196078431373f,0.0f,0.380392156863f),new Color(0.211764705882f,0.0f,0.407843137255f),new Color(0.227450980392f,0.0f,0.43137254902f),new Color(0.243137254902f,0.0f,0.458823529412f),new Color(0.254901960784f,0.0f,0.482352941176f),new Color(0.266666666667f,0.0f,0.501960784314f),new Color(0.278431372549f,0.0f,0.521568627451f),new Color(0.290196078431f,0.0f,0.545098039216f),new Color(0.305882352941f,0.0f,0.572549019608f),new Color(0.321568627451f,0.0f,0.6f),new Color(0.341176470588f,0.0f,0.635294117647f),new Color(0.364705882353f,0.0f,0.674509803922f),new Color(0.388235294118f,0.0f,0.713725490196f),new Color(0.411764705882f,0.0f,0.756862745098f),new Color(0.435294117647f,0.0f,0.8f),new Color(0.458823529412f,0.0f,0.843137254902f),new Color(0.486274509804f,0.0f,0.886274509804f),new Color(0.513725490196f,0.0f,0.933333333333f),new Color(0.541176470588f,0.0f,0.980392156863f),new Color(0.549019607843f,0.0f,1.0f),new Color(0.549019607843f,0.0f,1.0f),new Color(0.549019607843f,0.0f,1.0f),new Color(0.549019607843f,0.0f,1.0f),new Color(0.549019607843f,0.0f,1.0f),new Color(0.545098039216f,0.0f,1.0f),new Color(0.545098039216f,0.0f,1.0f),new Color(0.545098039216f,0.0f,1.0f),new Color(0.541176470588f,0.0f,1.0f),new Color(0.541176470588f,0.0f,1.0f),new Color(0.541176470588f,0.0f,1.0f),new Color(0.537254901961f,0.0f,1.0f),new Color(0.537254901961f,0.0f,1.0f),new Color(0.533333333333f,0.0f,1.0f),new Color(0.533333333333f,0.0f,1.0f),new Color(0.529411764706f,0.0f,1.0f),new Color(0.529411764706f,0.0f,1.0f),new Color(0.525490196078f,0.0f,1.0f),new Color(0.521568627451f,0.0f,1.0f),new Color(0.521568627451f,0.0f,1.0f),new Color(0.517647058824f,0.0f,1.0f),new Color(0.513725490196f,0.0f,1.0f),new Color(0.509803921569f,0.0f,1.0f),new Color(0.505882352941f,0.0f,1.0f),new Color(0.501960784314f,0.0f,1.0f),new Color(0.498039215686f,0.0f,1.0f),new Color(0.494117647059f,0.0f,1.0f),new Color(0.490196078431f,0.0f,1.0f),new Color(0.486274509804f,0.0f,1.0f),new Color(0.478431372549f,0.0f,1.0f),new Color(0.474509803922f,0.0f,1.0f),new Color(0.466666666667f,0.0f,1.0f),new Color(0.458823529412f,0.0f,1.0f),new Color(0.454901960784f,0.0f,1.0f),new Color(0.443137254902f,0.0f,1.0f),new Color(0.435294117647f,0.0f,1.0f),new Color(0.427450980392f,0.0f,1.0f),new Color(0.41568627451f,0.0f,1.0f),new Color(0.403921568627f,0.0f,1.0f),new Color(0.392156862745f,0.0f,1.0f),new Color(0.380392156863f,0.0f,1.0f),new Color(0.364705882353f,0.0f,1.0f),new Color(0.345098039216f,0.0f,1.0f),new Color(0.325490196078f,0.0f,1.0f),new Color(0.305882352941f,0.0f,1.0f),new Color(0.278431372549f,0.0f,1.0f),new Color(0.247058823529f,0.0f,1.0f),new Color(0.211764705882f,0.0f,1.0f),new Color(0.156862745098f,0.0f,1.0f),new Color(0.0666666666667f,0.0f,1.0f),new Color(0.0f,0.113725490196f,1.0f),new Color(0.0f,0.196078431373f,1.0f),new Color(0.0f,0.250980392157f,1.0f),new Color(0.0f,0.301960784314f,1.0f),new Color(0.0f,0.345098039216f,1.0f),new Color(0.0f,0.38431372549f,1.0f),new Color(0.0f,0.419607843137f,1.0f),new Color(0.0f,0.454901960784f,1.0f),new Color(0.0f,0.490196078431f,1.0f),new Color(0.0f,0.521568627451f,1.0f),new Color(0.0f,0.552941176471f,1.0f),new Color(0.0f,0.580392156863f,1.0f),new Color(0.0f,0.611764705882f,1.0f),new Color(0.0f,0.643137254902f,1.0f),new Color(0.0f,0.670588235294f,1.0f),new Color(0.0f,0.698039215686f,1.0f),new Color(0.0f,0.729411764706f,1.0f),new Color(0.0f,0.756862745098f,1.0f),new Color(0.0f,0.78431372549f,1.0f),new Color(0.0f,0.811764705882f,1.0f),new Color(0.0f,0.835294117647f,1.0f),new Color(0.0f,0.862745098039f,1.0f),new Color(0.0f,0.890196078431f,1.0f),new Color(0.0f,0.913725490196f,1.0f),new Color(0.0f,0.941176470588f,1.0f),new Color(0.0f,0.964705882353f,1.0f),new Color(0.0f,0.988235294118f,1.0f),new Color(0.0f,1.0f,0.988235294118f),new Color(0.0f,1.0f,0.964705882353f),new Color(0.0f,1.0f,0.945098039216f),new Color(0.0f,1.0f,0.925490196078f),new Color(0.0f,1.0f,0.905882352941f),new Color(0.0f,1.0f,0.890196078431f),new Color(0.0f,1.0f,0.874509803922f),new Color(0.0f,1.0f,0.858823529412f),new Color(0.0f,1.0f,0.847058823529f),new Color(0.0f,1.0f,0.83137254902f),new Color(0.0f,1.0f,0.819607843137f),new Color(0.0f,1.0f,0.807843137255f),new Color(0.0f,1.0f,0.796078431373f),new Color(0.0f,1.0f,0.78431372549f),new Color(0.0f,1.0f,0.776470588235f),new Color(0.0f,1.0f,0.764705882353f),new Color(0.0f,1.0f,0.756862745098f),new Color(0.0f,1.0f,0.745098039216f),new Color(0.0f,1.0f,0.737254901961f),new Color(0.0f,1.0f,0.729411764706f),new Color(0.0f,1.0f,0.721568627451f),new Color(0.0f,1.0f,0.713725490196f),new Color(0.0f,1.0f,0.705882352941f),new Color(0.0f,1.0f,0.698039215686f),new Color(0.0f,1.0f,0.690196078431f),new Color(0.0f,1.0f,0.682352941176f),new Color(0.0f,1.0f,0.674509803922f),new Color(0.0f,1.0f,0.666666666667f),new Color(0.0f,1.0f,0.662745098039f),new Color(0.0f,1.0f,0.654901960784f),new Color(0.0f,1.0f,0.647058823529f),new Color(0.0f,1.0f,0.639215686275f),new Color(0.0f,1.0f,0.635294117647f),new Color(0.0f,1.0f,0.627450980392f),new Color(0.0f,1.0f,0.619607843137f),new Color(0.0f,1.0f,0.611764705882f),new Color(0.0f,1.0f,0.603921568627f),new Color(0.0f,1.0f,0.596078431373f),new Color(0.0f,1.0f,0.588235294118f),new Color(0.0f,1.0f,0.576470588235f),new Color(0.0f,1.0f,0.56862745098f),new Color(0.0f,1.0f,0.560784313725f),new Color(0.0f,1.0f,0.549019607843f),new Color(0.0f,1.0f,0.537254901961f),new Color(0.0f,1.0f,0.525490196078f),new Color(0.0f,1.0f,0.513725490196f),new Color(0.0f,1.0f,0.498039215686f),new Color(0.0f,1.0f,0.486274509804f),new Color(0.0f,1.0f,0.466666666667f),new Color(0.0f,1.0f,0.450980392157f),new Color(0.0f,1.0f,0.427450980392f),new Color(0.0f,1.0f,0.407843137255f),new Color(0.0f,1.0f,0.380392156863f),new Color(0.0f,1.0f,0.349019607843f),new Color(0.0f,1.0f,0.309803921569f),new Color(0.0f,1.0f,0.262745098039f),new Color(0.0f,1.0f,0.192156862745f),new Color(0.0f,1.0f,0.0470588235294f),new Color(0.172549019608f,1.0f,0.0f),new Color(0.258823529412f,1.0f,0.0f),new Color(0.325490196078f,1.0f,0.0f),new Color(0.380392156863f,1.0f,0.0f),new Color(0.427450980392f,1.0f,0.0f),new Color(0.470588235294f,1.0f,0.0f),new Color(0.509803921569f,1.0f,0.0f),new Color(0.549019607843f,1.0f,0.0f),new Color(0.58431372549f,1.0f,0.0f),new Color(0.619607843137f,1.0f,0.0f),new Color(0.654901960784f,1.0f,0.0f),new Color(0.690196078431f,1.0f,0.0f),new Color(0.721568627451f,1.0f,0.0f),new Color(0.752941176471f,1.0f,0.0f),new Color(0.788235294118f,1.0f,0.0f),new Color(0.819607843137f,1.0f,0.0f),new Color(0.850980392157f,1.0f,0.0f),new Color(0.886274509804f,1.0f,0.0f),new Color(0.917647058824f,1.0f,0.0f),new Color(0.952941176471f,1.0f,0.0f),new Color(0.98431372549f,1.0f,0.0f),new Color(1.0f,0.98431372549f,0.0f),new Color(1.0f,0.949019607843f,0.0f),new Color(1.0f,0.917647058824f,0.0f),new Color(1.0f,0.890196078431f,0.0f),new Color(1.0f,0.862745098039f,0.0f),new Color(1.0f,0.835294117647f,0.0f),new Color(1.0f,0.807843137255f,0.0f),new Color(1.0f,0.780392156863f,0.0f),new Color(1.0f,0.756862745098f,0.0f),new Color(1.0f,0.733333333333f,0.0f),new Color(1.0f,0.709803921569f,0.0f),new Color(1.0f,0.686274509804f,0.0f),new Color(1.0f,0.662745098039f,0.0f),new Color(1.0f,0.643137254902f,0.0f),new Color(1.0f,0.619607843137f,0.0f),new Color(1.0f,0.6f,0.0f),new Color(1.0f,0.580392156863f,0.0f),new Color(1.0f,0.556862745098f,0.0f),new Color(1.0f,0.537254901961f,0.0f),new Color(1.0f,0.517647058824f,0.0f),new Color(1.0f,0.498039215686f,0.0f),new Color(1.0f,0.478431372549f,0.0f),new Color(1.0f,0.458823529412f,0.0f),new Color(1.0f,0.439215686275f,0.0f),new Color(1.0f,0.423529411765f,0.0f),new Color(1.0f,0.403921568627f,0.0f),new Color(1.0f,0.38431372549f,0.0f),new Color(1.0f,0.364705882353f,0.0f),new Color(1.0f,0.349019607843f,0.0f),new Color(1.0f,0.329411764706f,0.0f),new Color(1.0f,0.309803921569f,0.0f),new Color(1.0f,0.290196078431f,0.0f),new Color(1.0f,0.266666666667f,0.0f),new Color(1.0f,0.247058823529f,0.0f),new Color(1.0f,0.223529411765f,0.0f),new Color(1.0f,0.203921568627f,0.0f),new Color(1.0f,0.176470588235f,0.0f),new Color(1.0f,0.149019607843f,0.0f),new Color(1.0f,0.121568627451f,0.0f),new Color(1.0f,0.0823529411765f,0.0f),new Color(1.0f,0.0196078431373f,0.0f),new Color(1.0f,0.0f,0.0509803921569f),new Color(1.0f,0.0f,0.0941176470588f),new Color(1.0f,0.0f,0.121568627451f),new Color(1.0f,0.0f,0.145098039216f),new Color(1.0f,0.0f,0.160784313725f),new Color(1.0f,0.0f,0.176470588235f),new Color(1.0f,0.0f,0.188235294118f),new Color(1.0f,0.0f,0.2f),new Color(1.0f,0.0f,0.211764705882f),new Color(1.0f,0.0f,0.219607843137f),new Color(1.0f,0.0f,0.227450980392f),new Color(1.0f,0.0f,0.235294117647f),new Color(1.0f,0.0f,0.239215686275f),new Color(1.0f,0.0f,0.247058823529f),new Color(1.0f,0.0f,0.250980392157f),new Color(1.0f,0.0f,0.258823529412f),new Color(1.0f,0.0f,0.262745098039f),new Color(1.0f,0.0f,0.266666666667f),new Color(1.0f,0.0f,0.270588235294f),new Color(1.0f,0.0f,0.274509803922f),new Color(1.0f,0.0f,0.278431372549f),new Color(1.0f,0.0f,0.282352941176f),new Color(1.0f,0.0f,0.286274509804f),new Color(1.0f,0.0f,0.290196078431f),new Color(1.0f,0.0f,0.290196078431f),new Color(1.0f,0.0f,0.294117647059f),new Color(1.0f,0.0f,0.298039215686f),new Color(1.0f,0.0f,0.298039215686f),new Color(1.0f,0.0f,0.301960784314f),new Color(1.0f,0.0f,0.301960784314f),new Color(1.0f,0.0f,0.305882352941f),new Color(1.0f,0.0f,0.305882352941f),new Color(1.0f,0.0f,0.309803921569f),new Color(1.0f,0.0f,0.309803921569f),new Color(1.0f,0.0f,0.313725490196f),new Color(1.0f,0.0f,0.313725490196f),new Color(1.0f,0.0f,0.313725490196f),new Color(1.0f,0.0f,0.317647058824f),new Color(1.0f,0.0f,0.317647058824f),new Color(1.0f,0.0f,0.317647058824f),new Color(1.0f,0.0f,0.321568627451f),new Color(1.0f,0.0f,0.321568627451f),new Color(1.0f,0.0f,0.321568627451f),new Color(1.0f,0.0f,0.321568627451f),new Color(1.0f,0.0f,0.321568627451f),new Color(1.0f,0.0f,0.325490196078f),new Color(1.0f,0.0f,0.325490196078f),new Color(1.0f,0.0f,0.325490196078f),new Color(1.0f,0.0f,0.325490196078f),new Color(1.0f,0.0f,0.325490196078f),new Color(1.0f,0.0f,0.325490196078f),new Color(1.0f,0.0f,0.325490196078f),new Color(0.972549019608f,0.0f,0.317647058824f),new Color(0.945098039216f,0.0f,0.309803921569f),new Color(0.917647058824f,0.0f,0.298039215686f),new Color(0.894117647059f,0.0f,0.290196078431f),new Color(0.866666666667f,0.0f,0.282352941176f),new Color(0.843137254902f,0.0f,0.270588235294f),new Color(0.819607843137f,0.0f,0.262745098039f),new Color(0.796078431373f,0.0f,0.254901960784f),new Color(0.772549019608f,0.0f,0.247058823529f),new Color(0.752941176471f,0.0f,0.239215686275f),new Color(0.729411764706f,0.0f,0.23137254902f),new Color(0.709803921569f,0.0f,0.223529411765f),new Color(0.690196078431f,0.0f,0.219607843137f),new Color(0.670588235294f,0.0f,0.211764705882f),new Color(0.654901960784f,0.0f,0.203921568627f),new Color(0.635294117647f,0.0f,0.2f),new Color(0.619607843137f,0.0f,0.192156862745f),new Color(0.6f,0.0f,0.18431372549f),new Color(0.580392156863f,0.0f,0.180392156863f),new Color(0.564705882353f,0.0f,0.172549019608f),new Color(0.545098039216f,0.0f,0.164705882353f),new Color(0.525490196078f,0.0f,0.160784313725f),new Color(0.509803921569f,0.0f,0.152941176471f),new Color(0.490196078431f,0.0f,0.145098039216f),new Color(0.474509803922f,0.0f,0.141176470588f),new Color(0.458823529412f,0.0f,0.133333333333f),new Color(0.443137254902f,0.0f,0.129411764706f),new Color(0.427450980392f,0.0f,0.125490196078f),new Color(0.41568627451f,0.0f,0.117647058824f),new Color(0.4f,0.0f,0.113725490196f),new Color(0.388235294118f,0.0f,0.109803921569f),new Color(0.372549019608f,0.0f,0.101960784314f),new Color(0.360784313725f,0.0f,0.0980392156863f),new Color(0.349019607843f,0.0f,0.0941176470588f),new Color(0.341176470588f,0.0f,0.0901960784314f),new Color(0.329411764706f,0.0f,0.0862745098039f),new Color(0.317647058824f,0.0f,0.0823529411765f),new Color(0.309803921569f,0.0f,0.078431372549f),new Color(0.298039215686f,0.0f,0.0745098039216f),new Color(0.290196078431f,0.0f,0.0705882352941f),new Color(0.278431372549f,0.0f,0.0666666666667f),new Color(0.270588235294f,0.0f,0.0666666666667f),new Color(0.258823529412f,0.0f,0.0627450980392f),new Color(0.250980392157f,0.0f,0.0588235294118f),new Color(0.243137254902f,0.0f,0.0549019607843f),new Color(0.235294117647f,0.0f,0.0509803921569f),new Color(0.227450980392f,0.0f,0.0509803921569f),new Color(0.219607843137f,0.0f,0.0470588235294f),new Color(0.211764705882f,0.0f,0.043137254902f),new Color(0.203921568627f,0.0f,0.0392156862745f),new Color(0.196078431373f,0.0f,0.0392156862745f),new Color(0.188235294118f,0.0f,0.0352941176471f),new Color(0.18431372549f,0.0f,0.0313725490196f),new Color(0.176470588235f,0.0f,0.0313725490196f),new Color(0.16862745098f,0.0f,0.0274509803922f),new Color(0.164705882353f,0.0f,0.0274509803922f),new Color(0.156862745098f,0.0f,0.0235294117647f),new Color(0.149019607843f,0.0f,0.0235294117647f),new Color(0.145098039216f,0.0f,0.0235294117647f),new Color(0.137254901961f,0.0f,0.0196078431373f),new Color(0.133333333333f,0.0f,0.0196078431373f),new Color(0.129411764706f,0.0f,0.0196078431373f),new Color(0.121568627451f,0.0f,0.0156862745098f),new Color(0.117647058824f,0.0f,0.0156862745098f),new Color(0.113725490196f,0.0f,0.0156862745098f),new Color(0.105882352941f,0.0f,0.0117647058824f),new Color(0.101960784314f,0.0f,0.0117647058824f),new Color(0.0980392156863f,0.0f,0.0117647058824f),new Color(0.0941176470588f,0.0f,0.0117647058824f),new Color(0.0901960784314f,0.0f,0.0117647058824f),new Color(0.0862745098039f,0.0f,0.0078431372549f),new Color(0.0823529411765f,0.0f,0.0078431372549f),new Color(0.078431372549f,0.0f,0.0078431372549f),new Color(0.0745098039216f,0.0f,0.0078431372549f),new Color(0.0705882352941f,0.0f,0.0078431372549f),new Color(0.0666666666667f,0.0f,0.0078431372549f),new Color(0.0627450980392f,0.0f,0.0078431372549f),new Color(0.0588235294118f,0.0f,0.00392156862745f),new Color(0.0549019607843f,0.0f,0.00392156862745f),new Color(0.0509803921569f,0.0f,0.00392156862745f),new Color(0.0470588235294f,0.0f,0.00392156862745f),new Color(0.043137254902f,0.0f,0.00392156862745f),new Color(0.043137254902f,0.0f,0.00392156862745f),new Color(0.0392156862745f,0.0f,0.00392156862745f),new Color(0.0352941176471f,0.0f,0.00392156862745f),new Color(0.0352941176471f,0.0f,0.00392156862745f),new Color(0.0313725490196f,0.0f,0.00392156862745f),new Color(0.0274509803922f,0.0f,0.00392156862745f),new Color(0.0274509803922f,0.0f,0.00392156862745f),new Color(0.0235294117647f,0.0f,0.00392156862745f),new Color(0.0235294117647f,0.0f,0.00392156862745f),new Color(0.0235294117647f,0.0f,0.00392156862745f),new Color(0.0196078431373f,0.0f,0.0f),new Color(0.0196078431373f,0.0f,0.0f),new Color(0.0196078431373f,0.0f,0.0f),new Color(0.0156862745098f,0.0f,0.0f),new Color(0.0156862745098f,0.0f,0.0f),new Color(0.0156862745098f,0.0f,0.0f),new Color(0.0117647058824f,0.0f,0.0f),new Color(0.0117647058824f,0.0f,0.0f),new Color(0.0117647058824f,0.0f,0.0f),new Color(0.0117647058824f,0.0f,0.0f),new Color(0.0117647058824f,0.0f,0.0f),new Color(0.0078431372549f,0.0f,0.0f),new Color(0.0078431372549f,0.0f,0.0f),new Color(0.0078431372549f,0.0f,0.0f),new Color(0.0078431372549f,0.0f,0.0f),new Color(0.0078431372549f,0.0f,0.0f),new Color(0.0078431372549f,0.0f,0.0f),new Color(0.0078431372549f,0.0f,0.0f),new Color(0.0078431372549f,0.0f,0.0f),new Color(0.00392156862745f,0.0f,0.0f),new Color(0.00392156862745f,0.0f,0.0f),new Color(0.00392156862745f,0.0f,0.0f),new Color(0.00392156862745f,0.0f,0.0f),new Color(0.00392156862745f,0.0f,0.0f),new Color(0.00392156862745f,0.0f,0.0f),new Color(0.00392156862745f,0.0f,0.0f),new Color(0.00392156862745f,0.0f,0.0f),new Color(0.00392156862745f,0.0f,0.0f),new Color(0.00392156862745f,0.0f,0.0f),new Color(0.00392156862745f,0.0f,0.0f),new Color(0.00392156862745f,0.0f,0.0f),new Color(0.00392156862745f,0.0f,0.0f),new Color(0.00392156862745f,0.0f,0.0f),new Color(0.00392156862745f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f),new Color(0.0f,0.0f,0.0f)};




	void Awake()
	{
		//makes it a singleton
		if (jennyShoot == null)
		{
			jennyShoot = this;
		} else if (jennyShoot != this)
		{
			Destroy(gameObject);
		}
	}





	// Use this for initialization
	void Start () {



		canShoot = true;


		jennyTransform = PlatformerPushBodies.platformerPushBodies.transform;
			
		
		timeBetweenShots=0.3f;//This controls how often I can shoot!
		oneOverTimeBetweenShots=1.0f/timeBetweenShots;
		ratioOfTimes=0;
		shotComplete=false;
		
	

		



		SpeedOfLight       = GameControl.control.SpeedOfLight;
		SpeedOfLightY      = GameControl.control.SpeedOfLightY;
		dopplerSoftening   = GameControl.control.dopplerSoftening;
		initialPulseColour = GameControl.control.baseWavelength;






		ScaleFactorOfLight = SpeedOfLightY/SpeedOfLight;
		
		
		
		lorentzContractionForJenny = LorentzContractionForJenny.lCJenny;
			//GetComponent ("LorentzContractionForJenny")
			//as LorentzContractionForJenny;
		
		
		platformerController = PlatformerController.platformerController;

		//timeDilationJenny    = GetComponent ("TimeDilationJenny") as TimeDilationJenny;
		//hSBColourScript      = GetComponent ("HSBColourScript")  as HSBColourScript;
		
		
		
		
				
		
		timeOfShot=-10.0f;//this is initialized with a negative value so I can always shoot
		
		
		//the initial leght and width of a pulse before scaling
		//defaultPulseLength= 6.0f;
		//defaultPulseWidth = 2.0f;
		


	}




	void AssignThePulseColour()
	{// this can't be called in start since the mesh's get generated.  it is called by the DopplerCircle3 script (on a child of the canvas)

		shotDial = DopplerCircle3.dopplerCircle3.gameObject;
		shotDialCover	= shotDial.transform.FindChild("Cover");
		shotDialHolder	= shotDial.transform.FindChild("LifeBarOuter");
		dopplerCircle 	= shotDial.transform.FindChild("DopplerCircle");
		pulseDialColour = dopplerCircle.FindChild("PulseColour");
		//shotDial2 = transform.Find("GreenRing").gameObject;

		//The recovery dial is:

		wavelengthLabelMesh = shotDial.transform.FindChild("wavelengthLabel").
			GetComponentInChildren<TextMesh>();
		

		pulseDialMaterial=pulseDialColour.GetComponent<Renderer>().materials[0];
		//gun.transform.LookAt(Vector3.up);
		//gun.transform.rotation= Quaternion.LookRotation(Vector3.right);


		gun = GameObject.FindWithTag("Gun");
		VectorLine.SetCanvasCamera(Camera.main);
		VectorLine.SetCamera3D (Camera.main);
		gunLineVec = VectorLine.SetLine3D (Color.green, Vector3.zero ,// transform.position, 
		                                   new Vector3(10f,10f, 0f));
		gunLineVec.material = gunLineMaterial;
		gunLineVec.SetWidth(10f);
		gunLineVec.textureScale = 1f;


		if (!canShoot)//(!platformerController.canControl && !canShoot)
		{
			shotState = ShotState.turnOffShoot;
		}
		//VectorLine.SetLine (Color.green, new Vector3(0f,0f,0f), new Vector3(10f,0f,0f) );
		//gunLine = gun.transform.GetComponent<LineRenderer>();


	}
	
	
	
	
	
	
	
	
	// Update is called once per frame
	void Update () {
		
		//Animate the shotRecovery attached to the camera
		if (platformerController.jennyTime !=null){
		//if (timeOfShot !=null && platformerController.jennyTime !=null)
		//if (oneOverTimeBetweenShots !=null)
		//{
	

	
		ratioOfTimes = ( platformerController.jennyTime -timeOfShot)*oneOverTimeBetweenShots;
		} else 
		{
			ratioOfTimes = 1f;
		}

		if (ratioOfTimes<1.0f) {
			shotDial.GetComponent<Renderer>().material.SetFloat("_Cutoff", Mathf.Lerp(1,0, ratioOfTimes ) );
			//shotDial2.renderer.material.SetFloat("_Cutoff", Mathf.Lerp(1,0, ratioOfTimes ) );
		} else if (!shotComplete) {
			shotDial.GetComponent<Renderer>().material.SetFloat("_Cutoff", 0.0f );
			//shotDial2.renderer.material.SetFloat("_Cutoff", 0.0f );
			shotComplete=true;
		}


		//if (platformerController.canControl)
		//{
		ShotSwitchStatement();
		//}



	
	
	
	
	}






	void ShotSwitchStatement()
	{
		switch(shotState)
		{

		case (ShotState.canShoot):

			lorentzContractionForJenny.canShoot = true;
			if (!mouseShoot){
				if  (Input.GetButtonDown("Shoot") && platformerController.canControl
				     && ( shotComplete) ){
					
					HorizontalPulse();
					
					speedOfPulse = SpeedOfLight;
					
					photonPulseScript.wavelength= initialPulseColour*blueShift;
					photonPulseScript.nameOfShooter = gameObject.name;
					
					shotComplete = false;
				}
			} else {
				//1)THIS POINTS THE GUN AT THE MOUSE(AS LONG AS THE ANGLE IS BETWEEN 0 AND 180 DEGREES)
				//2)THIS WILL COLOUR THE MOUSE CURSOR WITH THE COLOUR OF THE SHOT
				
				//use the location of the mouse to create a direction of shot as well as 
				//have the gun track the pulse.
				mouseCoord = Input.mousePosition;
				
				
				gunCoord = Camera.main.WorldToScreenPoint(gun.transform.position);
				
				
				angleOfGun = GetAngleOfGun();
				gun.transform.rotation= Quaternion.LookRotation( new Vector3(
					gammaX*Mathf.Cos(angleOfGun),//the extra factor of gamma corrects the angle of the gun
					Mathf.Sin(angleOfGun),				//when jenny is lenght contracted.
					0f)  );
				
				gunLineRaycastHit = Physics2D.Raycast(new Vector2(gun.transform.position.x,gun.transform.position.y),
				                                      new Vector2(Mathf.Cos(angleOfGun), Mathf.Sin(angleOfGun)) ,
				                                      300f,//range of 200 for now, may need more
				                                      ~(1<<2)//|~(1<<9)
				                                      );//just ignores Jenny for now

				//gunLine.SetPosition(0, gun.transform.position);
				if (gunLineVec !=null)
				{
					gunLineVec.points3[0] = gun.transform.position;
					gunLineVec.points3[1] = gunLineRaycastHit.point;
					gunLineVec.Draw3D();
				}//if (gunLineRaycastHit !=null)
				//{
				//gunLine.SetPosition(1, gunLineRaycastHit.point);


				
				//The blue shift of the pulse will be calculated continuously
				blueShift =  DetermineDoplerShift(angleOfGun);
				
				
				
				//TELL THE SHOT DIAL WHAT NUMBER TO DISPLAY
				wavelengthLabelMesh.text = ((int)(blueShift*initialPulseColour)).ToString(   );
				//The colour of the display is



				pulseColor = returnColorFromAngle(angleOfGun);

			
				//pulseColor = CalculateTheColour(blueShift*initialPulseColour);
				Guncolour = pulseColor;
				//This makes the dial shine with the colour the pulse will produce
				pulseDialMaterial.SetColor("_Color",pulseColor);
				pulseDialMaterial.SetColor("_SpecColor",pulseColor);
				pulseDialMaterial.SetColor("_Emission" ,pulseColor);	
				
				//set the angle of the colour wedge to be the same as the gun's
				pulseDialColour.eulerAngles = new Vector3(0f,0f, angleOfGun*Mathf.Rad2Deg);
				
				//This is for the more complicated case of mouse shooting.		
				if  (Input.GetMouseButtonDown(0) && platformerController.canControl
				     && (shotComplete) ){
					
					MouseDirectedPulse();
					//assign the sonic doppler shift to the pulse
					photonPulseScript.sonicDopplerShift = DetermineSonicDoplerShift(angleOfGun);
					//send message to play noise.
					photonPulseClone.SendMessage("PlayShotSound",SendMessageOptions.DontRequireReceiver);

					photonPulseScript.wavelength= initialPulseColour*blueShift;
					photonPulseScript.nameOfShooter = gameObject.name;
					
					shotComplete=false;

					//give gun kick back
					CameraTracking.cameraTracking.ShotKickBack(angleOfGun);
				}
				
			}


			break;

		case (ShotState.startHolding):
			lorentzContractionForJenny.canShoot = false;
			//turn off the ray tracer of the gun
			gunLineVec.active = false;
			//turn off the shot dial
			shotDialCover.gameObject.SetActive(true);
			//shotDial.renderer.material.SetColor("_Color", Color.black);
			//dopplerCircle.renderer.material.SetColor("_Color", Color.gray);
			//shotDialHolder.renderer.material.SetColor("_Color", Color.black);
			//pulseDialColour.renderer.material.SetColor("_Color", Color.black);
			wavelengthLabelMesh.gameObject.SetActive(false);
			pulseDialColour.eulerAngles = new Vector3(0f,0f, -Mathf.PI/6f*Mathf.Rad2Deg);
			//gunLine.enabled = false;
			shotState = ShotState.holdingSomething;
			goto case ShotState.holdingSomething;
			//break;


		case (ShotState.turnOffShoot):
			lorentzContractionForJenny.canShoot = false;
			//turn off the ray tracer of the gun
			gunLineVec.active = false;
			//turn off the shot dial

			shotDialCover.gameObject.SetActive(true);
			wavelengthLabelMesh.gameObject.SetActive(false);
			//shotDial.renderer.material.SetColor("_Color", Color.black);
			//dopplerCircle.renderer.material.SetColor("_Color", Color.grey);
			//shotDialHolder.renderer.material.SetColor("_Color", Color.black);
			//pulseDialColour.renderer.material.SetColor("_Color", Color.black);

			shotState = ShotState.cantShoot;
			goto case ShotState.cantShoot;

		case (ShotState.cantShoot):

			break;

		case (ShotState.turnOnShoot):

			lorentzContractionForJenny.canShoot = true;
				/*
			gunLineVec = VectorLine.SetLine3D (Color.green, Vector3.zero ,// transform.position, 
			                                   new Vector3(10f,10f, 0f));
			gunLineVec.material = gunLineMaterial;
			gunLineVec.SetWidth(10f);
			gunLineVec.textureScale = 1f;
				*/
			//turn on the shot dial
			shotDialCover.gameObject.SetActive(false);
			//shotDial.renderer.material.SetColor("_Color", Color.white);
			//dopplerCircle.renderer.material.SetColor("_Color", Color.white);
			//shotDialHolder.renderer.material.SetColor("_Color", Color.white);
			//pulseDialColour.renderer.material.SetColor("_Color", Color.white);
			wavelengthLabelMesh.gameObject.SetActive(true);



			gunLineVec.active = true;
			//gunLine.enabled = true;
			shotState = ShotState.canShoot;
			goto case ShotState.canShoot;

			//break;


		case (ShotState.holdingSomething):
			lorentzContractionForJenny.canShoot = false;

			if (heldObject != null)
			{
				gun.transform.rotation= Quaternion.LookRotation(
					new Vector3( 
				            heldObject.position.x-gun.transform.position.x, 
				            heldObject.position.y-gun.transform.position.y,
				            0.0f
				            )  );
				break;
			} else
			{
				shotState = ShotState.turnOnShoot;
				goto case ShotState.turnOnShoot;
			}



		}
	}












	float GetAngleOfGun()
	{
		// scaled angle is needed to correctly set the velocity of the pulse
		gunCoord = Camera.main.WorldToScreenPoint(gun.transform.position);
		tempAngleGun =   Mathf.Atan2(mouseCoord.y -gunCoord.y , 
			                                mouseCoord.x -gunCoord.x );
		//define the angle we can look at
		if (tempAngleGun>-angleBelowHorizontal  || tempAngleGun < angleBelowHorizontal-Mathf.PI)
		{
		
			angleOfShotScaled = Mathf.Atan2(mouseCoord.y -gunCoord.y , 
			                                ScaleFactorOfLight*(mouseCoord.x -gunCoord.x) );

			return tempAngleGun;
		} else if (mouseCoord.x>gunCoord.x) 
		{

			angleOfShotScaled = Mathf.Atan(Mathf.Tan(-angleBelowHorizontal) / ScaleFactorOfLight );

			return -angleBelowHorizontal;


		} else 
		{

			angleOfShotScaled = Mathf.Atan( Mathf.Tan(angleBelowHorizontal-Mathf.PI ) / ScaleFactorOfLight )
				+Mathf.PI;//Not sure why I need to add a factor of pi here, but it works

			return angleBelowHorizontal-Mathf.PI;
		}


	
	}




	float DetermineDoplerShift(float angle){
	
		//Instantiate a pulse with corect origin
		locationOfShot=gun.transform.position;

		//the red or blue shift of the pulse is not just a factor of gamma
		//get gamma from lorentz contraction
		vX        = lorentzContractionForJenny.VxNew;
		vXOverC   = vX/SpeedOfLight; 
		
		//Calculate the doppler shift of the pulse
		if (Mathf.Sign(platformerController.movement.direction.x)>0.0f)
		{
			blueshiftFunction = SoftenedDopplerShift( vXOverC,angle);//OfShotInGame);
		} else
		{
			blueshiftFunction = SoftenedDopplerShift( vXOverC,Mathf.PI-angle);//OfShotInGame);
		}
		return blueshiftFunction;
		
	}



	float DetermineSonicDoplerShift(float angle){
		
		//Instantiate a pulse with corect origin
		locationOfShot=gun.transform.position;
		
		//the red or blue shift of the pulse is not just a factor of gamma
		//get gamma from lorentz contraction
		vX        = lorentzContractionForJenny.VxNew;
		vXOverC   = vX/SpeedOfLight; 
		
		//Calculate the doppler shift of the pulse
		if (Mathf.Sign(platformerController.movement.direction.x)>0.0f)
		{
			sonicDopplerShift = DopplerShift(vXOverC,angle);
		} else 
		{
			sonicDopplerShift = DopplerShift(vXOverC,Mathf.PI-angle);	
		}
		return sonicDopplerShift;
		
	}



	Color returnColorFromAngle( float theta2)//cosTheta2)
	{
		///
		///
		///
		///this is the new colour from the slower speed of light game 
		/// 
		/// 
		//the doppler shift is dopplerShift(softgamma, costheta)

		//aa = 1+dopplerSoftening*(gammaX-1);
		//vX        = lorentzContractionForJenny.VxNew;
		//vXOverC   = vX/SpeedOfLight;
		//gammaX = 1f/(  Mathf.Sqrt(1-Mathf.Pow(vXOverC,2.0f))  );

		//float shift = dopplerShift(1f+dopplerSoftening*(gammaX-1f) , cosTheta2);  
		float shift = DetermineDoplerShift(theta2);
		///This is a temp value
		Color baseColor = new Color(1f,0f,0f);
		float UV=0f, IR=0f;
		
		//this is a test color   
		Vector3 xyz = RGBToXYZC(baseColor.r,baseColor.g,baseColor.b);
		
		Vector3 weights = weightFromXYZCurves(xyz);
		Vector3 rParam,gParam,bParam,UVParam,IRParam;
		rParam.x = weights.x; rParam.y =  615f; rParam.z = 8f;
		gParam.x = weights.y; gParam.y =  550f; gParam.z = 4f;
		bParam.x = weights.z; bParam.y =  463f; bParam.z = 5f; 
		UVParam.x = 0.02f; UVParam.y = UV_START + UV_RANGE*UV; UVParam.z = 5f;
		IRParam.x = 0.02f; IRParam.y = IR_START + IR_RANGE*IR; IRParam.z = 5f;
		
		float xf = Mathf.Pow((1f/shift),3f)*getXFromCurve(rParam, shift) + getXFromCurve(gParam,shift) + getXFromCurve(bParam,shift) + getXFromCurve(IRParam,shift) + getXFromCurve(UVParam,shift);
		float yf = Mathf.Pow((1f/shift),3f)*getYFromCurve(rParam, shift) + getYFromCurve(gParam,shift) + getYFromCurve(bParam,shift) + getYFromCurve(IRParam,shift) + getYFromCurve(UVParam,shift);
		float zf = Mathf.Pow((1f/shift),3f)*getZFromCurve(rParam, shift) + getZFromCurve(gParam,shift) + getZFromCurve(bParam,shift) + getZFromCurve(IRParam,shift) + getZFromCurve(UVParam,shift);
		
		Vector3 rgbFinal = XYZToRGBC(xf,yf,zf);
		rgbFinal = constrainRGB(rgbFinal.x,rgbFinal.y, rgbFinal.z); //might not be needed
		
		//Test if unity_Scale is correct, unity occasionally does not give us the correct scale and you will see strange things in vertices,  this is just easy way to test
		//float4x4 temp  = mul(unity_Scale.w*_Object2World, _World2Object);
		//float4 temp2 = mul( temp,float4( (float)rgbFinal.x,(float)rgbFinal.y,(float)rgbFinal.z,data.a));
		//return temp2;	
		//float4 temp2 =float4( (float)rgbFinal.x,(float)rgbFinal.y,(float)rgbFinal.z,data.a );
		
		return new Color(rgbFinal.x,rgbFinal.y,rgbFinal.z);
		//return float4((float)rgbFinal.x,(float)rgbFinal.y,(float)rgbFinal.z,1.0); //use me for any real build
		





	}




	
	
	
	void SpawnThePulse(float blueShift, float initialPulseColour) {
		//set the colour of the pulse
				//3 cases: 1) 390>Lambda>700 visible
				//		   2) if the wavelength is greater than 700nm IR
				//		   3) Lambda<390 UV
		//scale the pulse to the correct default size
		photonPulseClone = Instantiate(horizontalPhotonPulse,locationOfShot,
		                               horizontalPhotonPulse.transform.rotation) as GameObject;
		
		
		//shotAudio = photonPulseClone.transform.GetComponent<AudioSource>();
		//shotAudio.Play();
		
		photonPulseScript = photonPulseClone.GetComponent("PhotonPulseSphere") as PhotonPulseSphere;
		
		
		//Get access to the colour of Mesh Renderer.
		photonRenderer = photonPulseClone.transform.GetComponent<MeshRenderer>();
		photonCloneMaterial=photonRenderer.materials[0];
		
		
		

		//This is the temporary one 
		pulseColor = returnColorFromAngle(angleOfGun);
		
		PulseColour = pulseColor;
		photonCloneMaterial.SetColor("_Color"    ,pulseColor);
		photonCloneMaterial.SetColor("_SpecColor",pulseColor);
		photonCloneMaterial.SetColor("_Emission" ,pulseColor);

		
		




	
		//This is for the case where a pulse is a sphere
		photonPulseClone.transform.localScale = new Vector3(
			1.5f,1.5f,1.5f);
		photonPulseClone.transform.position= new Vector3(
			photonPulseClone.transform.position.x,
			photonPulseClone.transform.position.y,
			0.0f);


	}
	
	
	void MouseDirectedPulse(){

		
		
		
		//This will creat the needed pulse.
		SpawnThePulse(blueShift,initialPulseColour);
		


		//set the direction and speed of the pulse
		photonPulseClone.transform.GetComponent<Rigidbody2D>().velocity= new Vector3(
			SpeedOfLight* Mathf.Cos(angleOfShotScaled),
			SpeedOfLightY*Mathf.Sin(angleOfShotScaled),
			0.0f);






		//the wavelength needs to be declared in the pulses script.
		photonPulseScript.wavelength = blueShift*initialPulseColour;
		
		
		
		//This keeps the pulses from being shot too often.
		timeOfShot=platformerController.jennyTime;
		photonPulseScript.speedOfPulse =  photonPulseClone.GetComponent<Rigidbody2D>().velocity.magnitude;
		//The mesh has 10X10 rectangles  //NOT ANYMORE!!!
		//photonPulseScript.widthOfMeshTriangle = photonPulseClone.transform.localScale.x*0.1f;
	
	

		
	}
	
	
	void HorizontalPulse(){
		//the red or blue shift of the pulse is not just a factor of gamma
		//get gamma from lorentz contraction
		vX        = lorentzContractionForJenny.VxNew;
		vXOverC   = vX/SpeedOfLight; 
		blueShift = SoftenedDopplerShift(vXOverC,0.0f);
		
		//the point where the Photon pulse originates
		locationOfShot=jennyTransform.position;
		
		
		
		//This will creat the needed pulse.
		SpawnThePulse(blueShift,initialPulseColour);
		
		
		
		//set the direction and scale of the pulse
		photonPulseClone.transform.GetComponent<Rigidbody2D>().velocity= new Vector3(
			Mathf.Sign(platformerController.movement.direction.x)*
			SpeedOfLight,0.0f,0.0f);
	
		photonPulseClone.transform.localScale = new Vector3(
			blueShift*photonPulseClone.transform.localScale.x,
					  photonPulseClone.transform.localScale.y,
					  photonPulseClone.transform.localScale.z);
		
		//the wavelength needs to be declared in the pulses script.
		photonPulseScript.wavelength = blueShift*initialPulseColour;
		
		
		
		//This keeps the pulses from being shot too often.
		timeOfShot=platformerController.jennyTime;
	}
	
	

	
	


	public float SoftenedDopplerShift( float vXOverC) {
		//This will calculate the doppler shift of a photon pulse collinear with vX
		//+ve sign in vxOverC means same direction.
	//Without blueshiftsoftening
		//return Mathf.Sqrt(  (1.0f-vXOverC)/(1.0f+vXOverC)  );
	//With blueshiftsoftening
		return 1.0f+dopplerSoftening*(Mathf.Sqrt(  (1.0f-vXOverC)/(1.0f+vXOverC)  )
		                                -1.0f);
	
	}
	
	public float SoftenedDopplerShift( float vXOverC, float angleInRestFrame) {
		//This will calculate the doppler shift of a photon pulse
		//theta=0 is when the photon is shot in the direction of motion
	//Without blueshiftsoftening
		//return (1.0f-Mathf.Abs(vXOverC)*Mathf.Cos(angleInRestFrame))/
		//	Mathf.Sqrt(1-Mathf.Pow(vXOverC,2.0f));
	//With blueshiftsoftening
		//return 1.0f+dopplerSoftening*(   
		 //      (    1.0f-Mathf.Abs(vXOverC)*Mathf.Cos(angleInRestFrame)    )/
		 //     (    Mathf.Sqrt(1-Mathf.Pow(vXOverC,2.0f))				   )  
		 //      -1.0f
		 //                               );
		gammaX = 1f/(  Mathf.Sqrt(1-Mathf.Pow(vXOverC,2.0f))  );
		a = 1+dopplerSoftening*(gammaX-1);//a is now the softened gamma factor.
		b = a* Mathf.Sqrt(1-Mathf.Pow(a,-2f)) ;
		return a -b * Mathf.Cos(angleInRestFrame);


		//return     dopplerSoftening*( 1.0f-Mathf.Abs(vXOverC)*Mathf.Cos(angleInRestFrame)  )/
		//	( Mathf.Sqrt(   1-Mathf.Pow(vXOverC,2.0f)  ) );  
		      
	}

	public float DopplerShift( float vXOverC, float angleInRestFrame) 
	{//for things like sound where the range is so much larger than the visible range we can  use the full spectrum
		gammaX = 1f/(  Mathf.Sqrt(1-Mathf.Pow(vXOverC,2.0f))  );
		a = gammaX;//a is now the none softened gamma factor.
		b = a*Mathf.Sqrt(1-Mathf.Pow(a,-2f)) ;
		return a -b * Mathf.Cos(angleInRestFrame);
	}








	///
	//THIS WILL BE THE COLOUR FUNCTIONS TAKEN FROM A SLOWER SPEED OF LIGHT SHADERS
	///
	//Color shift variables, used to make guassians for XYZ curves
	float xla = 0.39952807612909519f;
	float xlb = 444.63156780935032f;
	float xlc = 20.095464678736523f;
	
	float xha = 1.1305579611401821f;
	float xhb = 593.23109262398259f;
	float xhc = 34.446036241271742f;
	
	float ya = 1.0098874822455657f;
	float yb = 556.03724875218927f;
	float yc = 46.184868454550838f;
	
	float za = 2.0648400466720593f;
	float zb = 448.45126344558236f;
	float zc = 22.357297606503543f;
	
	//Used to determine where to center UV/IR curves
	float IR_RANGE = 400f;
	float IR_START = 700f;
	float UV_RANGE = 380f;
	float UV_START = 0f;










	//I need the doppler shift formula from Jenny shoot
	
	float dopplerShift(float aa, float cosTheta)
	{     
		//aa is now the softened gamma factor.  Still has the range [1,infinity]
		//aa = 1+dopplerSoftening*(gammaX-1);
		//sign of aa is the direction jenny's facing 
		
		float b = aa*Mathf.Sign(platformerController.movement.direction.x)* Mathf.Sqrt(1-Mathf.Pow(aa,-2f)) ;
		
		return  (aa - b*cosTheta  );
	}
	

	//Color functions, there's no check for division by 0 which may cause issues on
	//some graphics cards.
	Vector3 RGBToXYZC(  float r,  float g,  float b)
	{
		Vector3 xyz;
		xyz.x = 0.13514f*r + 0.120432f*g + 0.057128f*b;
		xyz.y = 0.0668999f*r + 0.232706f*g + 0.0293946f*b;
		xyz.z = 0.0f*r + 0.0000218959f*g + 0.358278f*b;
		return xyz;
	}
	Vector3 XYZToRGBC(  float x,  float y,  float z)
	{
		Vector3 rgb;
		rgb.x = 9.94845f*x -5.1485f*y - 1.16389f*z;
		rgb.y = -2.86007f*x + 5.77745f*y - 0.0179627f*z;
		rgb.z = 0.000174791f*x - 0.000353084f*y + 2.79113f*z;
		
		return rgb;
	}
	
	
	Vector3 weightFromXYZCurves(Vector3 xyz)
	{
		Vector3 returnVal;
		returnVal.x = 0.0735806f * xyz.x -0.0380793f * xyz.y - 0.00860837f * xyz.z;
		returnVal.y = -0.0665378f * xyz.x +  0.134408f * xyz.y - 0.000417865f * xyz.z;
		returnVal.z = 0.00000299624f * xyz.x - 0.00000605249f * xyz.y + 0.0484424f * xyz.z;
		return returnVal;
	}
	
	
	float getXFromCurve(Vector3 param,  float shift)
	{
		float top1 = param.x * xla * Mathf.Exp( 
			-(Mathf.Pow((param.y*shift) - xlb,2f)/(2f*(  Mathf.Pow(param.z*shift,2f) + Mathf.Pow(xlc,2f)   ))  )
		                                       )*Mathf.Sqrt( 2f*3.14159265358979323f);
		float bottom1 = Mathf.Sqrt(  1f/Mathf.Pow(param.z*shift,2f) +(1/Mathf.Pow(xlc,2f))); 
		
		float top2 = param.x * xha * Mathf.Exp( (  -(Mathf.Pow((param.y*shift) - xhb,2f)
		                                          /(2f*(Mathf.Pow(param.z*shift,2f)+Mathf.Pow(xhc,2f))))))*Mathf.Sqrt( (float)(2f*3.14159265358979323f));
		float bottom2 = Mathf.Sqrt(  1/Mathf.Pow(param.z*shift,2f)  +(1/Mathf.Pow(xhc,2f)));
		
		return (top1/bottom1) + (top2/bottom2);
	}
	
	
	float getYFromCurve(Vector3 param,  float shift)
	{
		float top = param.x * ya * Mathf.Exp( -(Mathf.Pow((param.y*shift) - yb,2f)
		                                              /(  2f*(Mathf.Pow(param.z*shift,2f)+Mathf.Pow(yc,2f)))  )
		                                     )*Mathf.Sqrt( 2f*3.14159265358979323f);
		float bottom = Mathf.Sqrt(  1/Mathf.Pow(param.z*shift,2f)  +(1/Mathf.Pow(yc,2f))); 
		
		return top/bottom;
	}
	
	float getZFromCurve(Vector3 param,  float shift)
	{
		float top = param.x * za * Mathf.Exp(
			-(  Mathf.Pow((param.y*shift) - zb,2f) / (2f*(Mathf.Pow(param.z*shift,2f)+Mathf.Pow(zc,2f)))   )
		                                     )*Mathf.Sqrt( 2f*3.14159265358979323f);
		float bottom = Mathf.Sqrt(   1/Mathf.Pow(param.z*shift,2f)  +1/Mathf.Pow(zc,2f)   );
		
		return top/bottom;
	}
	
	Vector3 constrainRGB( float r,  float g,  float b)
	{
		float w;
		
		w = (0 < r) ? 0 : r;
		w = (w < g) ? w : g;
		w = (w < b) ? w : b;
		w = -w;
		
		if (w > 0) {
			r += w;  g += w; b += w;
		}
		w = r;
		w = ( w < g) ? g : w;
		w = ( w < b) ? b : w;
		
		if ( w > 1 )
		{
			r /= w;
			g /= w;
			b /= w;
		}	
		Vector3 rgb;
		rgb.x = r;
		rgb.y = g;
		rgb.z = b;
		return rgb;
		
	}
	



























	
}
